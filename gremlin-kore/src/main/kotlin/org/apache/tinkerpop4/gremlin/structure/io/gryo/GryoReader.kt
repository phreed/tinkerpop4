/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.tinkerpop4.gremlin.structure.io.gryo

import org.apache.tinkerpop4.gremlin.process.computer.GraphFilter

/**
 * The [GraphReader] for the Gremlin Structure serialization format based on Kryo.  The format is meant to be
 * non-lossy in terms of Gremlin Structure to Gremlin Structure migrations (assuming both structure implementations
 * support the same graph features).
 *
 *
 * This implementation is not thread-safe.  Have one `GryoReader` instance per thread.
 *
 * @author Stephen Mallette (http://stephen.genoprime.com)
 * @author Marko A. Rodriguez (http://markorodriguez.com)
 */
class GryoReader private constructor(batchSize: Long, gryoMapper: Mapper<Kryo>) : GraphReader {
    private val kryo: Kryo
    private val graphFilterCache: Map<GraphFilter, StarGraphGryoSerializer> = HashMap()
    private val batchSize: Long

    init {
        kryo = gryoMapper.createMapper()
        this.batchSize = batchSize
    }

    /**
     * Read data into a [Graph] from output generated by any of the [GryoWriter] `writeVertex` or
     * `writeVertices` methods or by [GryoWriter.writeGraph].
     *
     * @param inputStream    a stream containing an entire graph of vertices and edges as defined by the accompanying
     * [GraphWriter.writeGraph].
     * @param graphToWriteTo the graph to write to when reading from the stream.
     * @throws IOException
     */
    @Override
    @Throws(IOException::class)
    fun readGraph(inputStream: InputStream?, graphToWriteTo: Graph) {
        // dual pass - create all vertices and store to cache the ids.  then create edges.  as long as we don't
        // have vertex labels in the output we can't do this single pass
        val cache: Map<StarVertex, Vertex> = HashMap()
        val counter = AtomicLong(0)
        val edgeFeatures: EdgeFeatures = graphToWriteTo.features().edge()
        val supportsTx: Boolean = graphToWriteTo.features().graph().supportsTransactions()
        IteratorUtils.iterate(
            VertexInputIterator(
                Input(inputStream),
                Function<Attachable<Vertex>, Vertex> { attachable ->
                    val v: Vertex = cache.put(
                        attachable.get() as StarVertex,
                        attachable.attach(Attachable.Method.create(graphToWriteTo))
                    )
                    if (supportsTx && counter.incrementAndGet() % batchSize === 0) graphToWriteTo.tx().commit()
                    v
                },
                null,
                null
            )
        )
        cache.entrySet().forEach { kv ->
            kv.getKey().edges(Direction.IN).forEachRemaining { e ->
                // can't use a standard Attachable attach method here because we have to use the cache for those
                // graphs that don't support userSuppliedIds on edges. note that outVertex/inVertex methods return
                // StarAdjacentVertex whose equality should match StarVertex.
                val cachedOutV: Vertex? = cache[e.outVertex()]
                val cachedInV: Vertex? = cache[e.inVertex()]
                if (null == cachedOutV) throw IllegalStateException(
                    String.format(
                        "Could not find outV with id [%s] to create edge with id [%s]",
                        e.outVertex().id(),
                        e.id()
                    )
                )
                if (null == cachedInV) throw IllegalStateException(
                    String.format(
                        "Could not find inV with id [%s] to create edge with id [%s]",
                        e.inVertex().id(),
                        e.id()
                    )
                )
                val newEdge: Edge = if (edgeFeatures.willAllowId(e.id())) cachedOutV.addEdge(
                    e.label(),
                    cachedInV,
                    T.id,
                    e.id()
                ) else cachedOutV.addEdge(e.label(), cachedInV)
                e.properties().forEachRemaining { p -> newEdge.property(p.key(), p.value()) }
                if (supportsTx && counter.incrementAndGet() % batchSize === 0) graphToWriteTo.tx().commit()
            }
        }
        if (supportsTx) graphToWriteTo.tx().commit()
    }

    @Override
    @Throws(IOException::class)
    fun readVertex(inputStream: InputStream?, graphFilter: GraphFilter): Optional<Vertex> {
        var serializer: StarGraphGryoSerializer? = graphFilterCache[graphFilter]
        if (null == serializer) {
            serializer = StarGraphGryoSerializer.withGraphFilter(graphFilter)
            graphFilterCache.put(graphFilter, serializer)
        }
        val input = Input(inputStream)
        readHeader(input)
        val starGraph: StarGraph = kryo.readObject(input, StarGraph::class.java, serializer)
        // read the terminator
        kryo.readClassAndObject(input)
        return Optional.ofNullable(if (starGraph == null) null else starGraph.getStarVertex())
    }

    /**
     * Read [Vertex] objects from output generated by any of the [GryoWriter] `writeVertex` or
     * `writeVertices` methods or by [GryoWriter.writeGraph].
     *
     * @param inputStream                a stream containing at least one [Vertex] as defined by the accompanying
     * [GraphWriter.writeVertices] or
     * [GraphWriter.writeVertices] methods.
     * @param vertexAttachMethod         a function that creates re-attaches a [Vertex] to a [Host] object.
     * @param edgeAttachMethod           a function that creates re-attaches a [Edge] to a [Host] object.
     * @param attachEdgesOfThisDirection only edges of this direction are passed to the `edgeMaker`.
     */
    @Override
    @Throws(IOException::class)
    fun readVertices(
        inputStream: InputStream?,
        vertexAttachMethod: Function<Attachable<Vertex?>?, Vertex?>,
        edgeAttachMethod: Function<Attachable<Edge?>?, Edge?>,
        attachEdgesOfThisDirection: Direction?
    ): Iterator<Vertex> {
        return VertexInputIterator(Input(inputStream), vertexAttachMethod, attachEdgesOfThisDirection, edgeAttachMethod)
    }

    /**
     * Read a [Vertex]  from output generated by any of the [GryoWriter] `writeVertex` or
     * `writeVertices` methods or by [GryoWriter.writeGraph].
     *
     * @param inputStream        a stream containing at least a single vertex as defined by the accompanying
     * [GraphWriter.writeVertex].
     * @param vertexAttachMethod a function that creates re-attaches a [Vertex] to a [Host] object.
     */
    @Override
    @Throws(IOException::class)
    fun readVertex(inputStream: InputStream?, vertexAttachMethod: Function<Attachable<Vertex?>?, Vertex?>): Vertex {
        return readVertex(inputStream, vertexAttachMethod, null, null)
    }

    /**
     * Read a [Vertex] from output generated by any of the [GryoWriter] `writeVertex` or
     * `writeVertices` methods or by [GryoWriter.writeGraph].
     *
     * @param inputStream                a stream containing at least one [Vertex] as defined by the accompanying
     * [GraphWriter.writeVertices] method.
     * @param vertexAttachMethod         a function that creates re-attaches a [Vertex] to a [Host] object.
     * @param edgeAttachMethod           a function that creates re-attaches a [Edge] to a [Host] object.
     * @param attachEdgesOfThisDirection only edges of this direction are passed to the `edgeMaker`.
     */
    @Override
    @Throws(IOException::class)
    fun readVertex(
        inputStream: InputStream?,
        vertexAttachMethod: Function<Attachable<Vertex?>?, Vertex?>,
        edgeAttachMethod: Function<Attachable<Edge>, Edge>?,
        attachEdgesOfThisDirection: Direction?
    ): Vertex {
        val input = Input(inputStream)
        return readVertexInternal(vertexAttachMethod, edgeAttachMethod, attachEdgesOfThisDirection, input)
    }

    /**
     * Read an [Edge] from output generated by [GryoWriter.writeEdge] or via
     * an [Edge] passed to [GryoWriter.writeObject].
     *
     * @param inputStream      a stream containing at least one [Edge] as defined by the accompanying
     * [GraphWriter.writeEdge] method.
     * @param edgeAttachMethod a function that creates re-attaches a [Edge] to a [Host] object.
     */
    @Override
    @Throws(IOException::class)
    fun readEdge(inputStream: InputStream?, edgeAttachMethod: Function<Attachable<Edge?>?, Edge?>): Edge {
        val input = Input(inputStream)
        readHeader(input)
        val attachable: Attachable<Edge> = kryo.readObject(input, DetachedEdge::class.java)
        return edgeAttachMethod.apply(attachable)
    }

    /**
     * Read a [VertexProperty] from output generated by
     * [GryoWriter.writeVertexProperty] or via an [VertexProperty] passed
     * to [GryoWriter.writeObject].
     *
     * @param inputStream                a stream containing at least one [VertexProperty] as written by the accompanying
     * [GraphWriter.writeVertexProperty] method.
     * @param vertexPropertyAttachMethod a function that creates re-attaches a [VertexProperty] to a
     * [Host] object.
     */
    @Override
    @Throws(IOException::class)
    fun readVertexProperty(
        inputStream: InputStream?,
        vertexPropertyAttachMethod: Function<Attachable<VertexProperty?>?, VertexProperty?>
    ): VertexProperty {
        val input = Input(inputStream)
        readHeader(input)
        val attachable: Attachable<VertexProperty> = kryo.readObject(input, DetachedVertexProperty::class.java)
        return vertexPropertyAttachMethod.apply(attachable)
    }

    /**
     * Read a [Property] from output generated by  [GryoWriter.writeProperty] or
     * via an [Property] passed to [GryoWriter.writeObject].
     *
     * @param inputStream          a stream containing at least one [Property] as written by the accompanying
     * [GraphWriter.writeProperty] method.
     * @param propertyAttachMethod a function that creates re-attaches a [Property] to a [Host] object.
     */
    @Override
    @Throws(IOException::class)
    fun readProperty(
        inputStream: InputStream?,
        propertyAttachMethod: Function<Attachable<Property?>?, Property?>
    ): Property {
        val input = Input(inputStream)
        readHeader(input)
        val attachable: Attachable<Property> = kryo.readObject(input, DetachedProperty::class.java)
        return propertyAttachMethod.apply(attachable)
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Throws(IOException::class)
    fun <C> readObject(inputStream: InputStream?, clazz: Class<out C>): C {
        return clazz.cast(kryo.readClassAndObject(Input(inputStream)))
    }

    @Throws(IOException::class)
    private fun readVertexInternal(
        vertexMaker: Function<Attachable<Vertex?>?, Vertex?>,
        edgeMaker: Function<Attachable<Edge>, Edge>?,
        d: Direction?,
        input: Input
    ): Vertex {
        readHeader(input)
        val starGraph: StarGraph = kryo.readObject(input, StarGraph::class.java)

        // read the terminator
        kryo.readClassAndObject(input)
        val v: Vertex = vertexMaker.apply(starGraph.getStarVertex())
        if (edgeMaker != null) starGraph.getStarVertex().edges(d)
            .forEachRemaining { e -> edgeMaker.apply(e as Attachable<Edge?>) }
        return v
    }

    @Throws(IOException::class)
    private fun readHeader(input: Input) {
        if (!Arrays.equals(
                GryoMapper.GIO,
                input.readBytes(3)
            )
        ) throw IOException("Invalid format - first three bytes of header do not match expected value")

        // skip the next 13 bytes - for future use
        input.readBytes(13)
    }

    class Builder : ReaderBuilder<GryoReader?> {
        private var batchSize: Long = 10000

        /**
         * Always use the most recent gryo version by default
         */
        private var gryoMapper: Mapper<Kryo> = GryoMapper.build().create()

        /**
         * Number of mutations to perform before a commit is executed when using
         * [GryoReader.readGraph].
         */
        fun batchSize(batchSize: Long): Builder {
            this.batchSize = batchSize
            return this
        }

        /**
         * Supply a mapper [GryoMapper] instance to use as the serializer for the `KryoWriter`.
         */
        fun mapper(gryoMapper: Mapper<Kryo?>): Builder {
            this.gryoMapper = gryoMapper
            return this
        }

        fun create(): GryoReader {
            return GryoReader(batchSize, gryoMapper)
        }
    }

    private inner class VertexInputIterator(
        input: Input,
        vertexMaker: Function<Attachable<Vertex?>?, Vertex?>,
        d: Direction?,
        edgeMaker: Function<Attachable<Edge?>?, Edge?>
    ) : Iterator<Vertex?> {
        private val input: Input
        private val vertexMaker: Function<Attachable<Vertex?>?, Vertex?>
        private val d: Direction?
        private val edgeMaker: Function<Attachable<Edge>, Edge>

        init {
            this.input = input
            this.d = d
            this.edgeMaker = edgeMaker
            this.vertexMaker = vertexMaker
        }

        @Override
        override fun hasNext(): Boolean {
            return !input.eof()
        }

        @Override
        override fun next(): Vertex {
            return try {
                readVertexInternal(vertexMaker, edgeMaker, d, input)
            } catch (ex: Exception) {
                throw RuntimeException(ex)
            }
        }
    }

    companion object {
        fun build(): Builder {
            return Builder()
        }
    }
}