/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.tinkerpop4.gremlin.structure.io.graphson

import org.apache.tinkerpop4.gremlin.structure.Direction

/**
 * A @{link GraphReader} that constructs a graph from a JSON-based representation of a graph and its elements.
 * This implementation only supports JSON data types and is therefore lossy with respect to data types (e.g. a
 * float will become a double, element IDs may not be retrieved in the format they were serialized, etc.).
 * [Edge] and [Vertex] objects are serialized to `Map` instances.  If an
 * [Element] is used as a key, it is coerced to its identifier.  Other complex  objects are converted via
 * [Object.toString] unless there is a mapper serializer supplied.
 *
 * @author Stephen Mallette (http://stephen.genoprime.com)
 */
class GraphSONReader private constructor(builder: Builder) : GraphReader {
    private val mapper: ObjectMapper
    private val batchSize: Long
    private val version: GraphSONVersion
    private var unwrapAdjacencyList = false
    val mapTypeReference: TypeReference<Map<String, Object>> = object : TypeReference<Map<String?, Object?>?>() {}
    val linkedHashMapTypeReference: TypeReference<LinkedHashMap<String, Object>> =
        object : TypeReference<LinkedHashMap<String?, Object?>?>() {}

    init {
        mapper = builder.mapper.createMapper()
        batchSize = builder.batchSize
        unwrapAdjacencyList = builder.unwrapAdjacencyList
        version = (builder.mapper as GraphSONMapper).getVersion()
    }

    /**
     * Read data into a [Graph] from output generated by any of the [GraphSONWriter] `writeVertex` or
     * `writeVertices` methods or by [GryoWriter.writeGraph].
     *
     * @param inputStream a stream containing an entire graph of vertices and edges as defined by the accompanying
     * [GraphSONWriter.writeGraph].
     * @param graphToWriteTo the graph to write to when reading from the stream.
     */
    @Override
    @Throws(IOException::class)
    fun readGraph(inputStream: InputStream, graphToWriteTo: Graph) {
        // dual pass - create all vertices and store to cache the ids.  then create edges.  as long as we don't
        // have vertex labels in the output we can't do this single pass
        val cache: Map<StarVertex, Vertex> = HashMap()
        val counter = AtomicLong(0)
        val supportsTx: Boolean = graphToWriteTo.features().graph().supportsTransactions()
        val edgeFeatures: EdgeFeatures = graphToWriteTo.features().edge()
        readVertexStrings(inputStream).< Vertex > map < Vertex ? > FunctionUtils.wrapFunction { line ->
            readVertex(
                ByteArrayInputStream(line.getBytes()),
                null,
                null,
                Direction.IN
            )
        }
            .forEach { vertex ->
                val attachable: Attachable<Vertex> = vertex as Attachable<Vertex>
                cache.put(attachable.get() as StarVertex, attachable.attach(Attachable.Method.create(graphToWriteTo)))
                if (supportsTx && counter.incrementAndGet() % batchSize === 0) graphToWriteTo.tx().commit()
            }
        cache.entrySet().forEach { kv ->
            kv.getKey().edges(Direction.IN).forEachRemaining { e ->
                // can't use a standard Attachable attach method here because we have to use the cache for those
                // graphs that don't support userSuppliedIds on edges.  note that outVertex/inVertex methods return
                // StarAdjacentVertex whose equality should match StarVertex.
                val cachedOutV: Vertex? = cache[e.outVertex()]
                val cachedInV: Vertex? = cache[e.inVertex()]
                if (null == cachedOutV) throw IllegalStateException(
                    String.format(
                        "Could not find outV with id [%s] to create edge with id [%s]",
                        e.outVertex().id(),
                        e.id()
                    )
                )
                if (null == cachedInV) throw IllegalStateException(
                    String.format(
                        "Could not find inV with id [%s] to create edge with id [%s]",
                        e.inVertex().id(),
                        e.id()
                    )
                )
                val newEdge: Edge = if (edgeFeatures.willAllowId(e.id())) cachedOutV.addEdge(
                    e.label(),
                    cachedInV,
                    T.id,
                    e.id()
                ) else cachedOutV.addEdge(e.label(), cachedInV)
                e.properties().forEachRemaining { p -> newEdge.property(p.key(), p.value()) }
                if (supportsTx && counter.incrementAndGet() % batchSize === 0) graphToWriteTo.tx().commit()
            }
        }
        if (supportsTx) graphToWriteTo.tx().commit()
    }

    /**
     * Read [Vertex] objects from output generated by any of the [GraphSONWriter] `writeVertex` or
     * `writeVertices` methods or by [GraphSONWriter.writeGraph].
     *
     * @param inputStream a stream containing at least one [Vertex] as defined by the accompanying
     * [GraphWriter.writeVertices] or
     * [GraphWriter.writeVertices] methods.
     * @param vertexAttachMethod a function that creates re-attaches a [Vertex] to a [Host] object.
     * @param edgeAttachMethod a function that creates re-attaches a [Edge] to a [Host] object.
     * @param attachEdgesOfThisDirection only edges of this direction are passed to the `edgeMaker`.
     */
    @Override
    @Throws(IOException::class)
    fun readVertices(
        inputStream: InputStream,
        vertexAttachMethod: Function<Attachable<Vertex?>?, Vertex?>?,
        edgeAttachMethod: Function<Attachable<Edge?>?, Edge?>?,
        attachEdgesOfThisDirection: Direction?
    ): Iterator<Vertex> {
        return readVertexStrings(inputStream).< Vertex > map < Vertex ? > FunctionUtils.wrapFunction { line ->
            readVertex(
                ByteArrayInputStream(line.getBytes()),
                vertexAttachMethod,
                edgeAttachMethod,
                attachEdgesOfThisDirection
            )
        }
            .iterator()
    }

    /**
     * Read a [Vertex]  from output generated by any of the [GraphSONWriter] `writeVertex` or
     * `writeVertices` methods or by [GraphSONWriter.writeGraph].
     *
     * @param inputStream a stream containing at least a single vertex as defined by the accompanying
     * [GraphWriter.writeVertex].
     * @param vertexAttachMethod a function that creates re-attaches a [Vertex] to a [Host] object.
     */
    @Override
    @Throws(IOException::class)
    fun readVertex(inputStream: InputStream?, vertexAttachMethod: Function<Attachable<Vertex?>?, Vertex?>?): Vertex {
        return readVertex(inputStream, vertexAttachMethod, null, null)
    }

    /**
     * Read a [Vertex] from output generated by any of the [GraphSONWriter] `writeVertex` or
     * `writeVertices` methods or by [GraphSONWriter.writeGraph].
     *
     * @param inputStream a stream containing at least one [Vertex] as defined by the accompanying
     * [GraphWriter.writeVertices] method.
     * @param vertexAttachMethod a function that creates re-attaches a [Vertex] to a [Host] object.
     * @param edgeAttachMethod a function that creates re-attaches a [Edge] to a [Host] object.
     * @param attachEdgesOfThisDirection only edges of this direction are passed to the `edgeMaker`.
     */
    @Override
    @Throws(IOException::class)
    fun readVertex(
        inputStream: InputStream?,
        vertexAttachMethod: Function<Attachable<Vertex?>?, Vertex?>?,
        edgeAttachMethod: Function<Attachable<Edge?>?, Edge?>?,
        attachEdgesOfThisDirection: Direction?
    ): Vertex {
        // graphson v3 has special handling for generic Map instances, by forcing to linkedhashmap (which is probably
        // what it should have been anyway) stargraph format can remain unchanged across all versions
        val vertexData: Map<String, Object> = if (version === GraphSONVersion.V3_0) mapper.readValue(
            inputStream,
            linkedHashMapTypeReference
        ) else mapper.readValue(inputStream, mapTypeReference)
        val starGraph: StarGraph = StarGraphGraphSONDeserializer.readStarGraphVertex(vertexData)
        if (vertexAttachMethod != null) vertexAttachMethod.apply(starGraph.getStarVertex())
        if (vertexData.containsKey(GraphSONTokens.OUT_E) && (attachEdgesOfThisDirection === Direction.BOTH || attachEdgesOfThisDirection === Direction.OUT)) StarGraphGraphSONDeserializer.readStarGraphEdges(
            edgeAttachMethod,
            starGraph,
            vertexData,
            GraphSONTokens.OUT_E
        )
        if (vertexData.containsKey(GraphSONTokens.IN_E) && (attachEdgesOfThisDirection === Direction.BOTH || attachEdgesOfThisDirection === Direction.IN)) StarGraphGraphSONDeserializer.readStarGraphEdges(
            edgeAttachMethod,
            starGraph,
            vertexData,
            GraphSONTokens.IN_E
        )
        return starGraph.getStarVertex()
    }

    /**
     * Read an [Edge] from output generated by [GraphSONWriter.writeEdge] or via
     * an [Edge] passed to [GraphSONWriter.writeObject].
     *
     * @param inputStream a stream containing at least one [Edge] as defined by the accompanying
     * [GraphWriter.writeEdge] method.
     * @param edgeAttachMethod a function that creates re-attaches a [Edge] to a [Host] object.
     */
    @Override
    @Throws(IOException::class)
    fun readEdge(inputStream: InputStream?, edgeAttachMethod: Function<Attachable<Edge?>?, Edge?>): Edge {
        return if (version === GraphSONVersion.V1_0) {
            val edgeData: Map<String, Object> = mapper.readValue(inputStream, mapTypeReference)
            val edgeProperties: Map<String, Object>? =
                if (edgeData.containsKey(GraphSONTokens.PROPERTIES)) edgeData[GraphSONTokens.PROPERTIES] else Collections.EMPTY_MAP
            val edge = DetachedEdge(
                edgeData[GraphSONTokens.ID],
                edgeData[GraphSONTokens.LABEL].toString(),
                edgeProperties,
                edgeData[GraphSONTokens.OUT], edgeData[GraphSONTokens.OUT_LABEL].toString(),
                edgeData[GraphSONTokens.IN], edgeData[GraphSONTokens.IN_LABEL].toString()
            )
            edgeAttachMethod.apply(edge)
        } else {
            edgeAttachMethod.apply(mapper.readValue(inputStream, Edge::class.java) as DetachedEdge)
        }
    }

    /**
     * Read a [VertexProperty] from output generated by
     * [GraphSONWriter.writeVertexProperty] or via an [VertexProperty] passed
     * to [GraphSONWriter.writeObject].
     *
     * @param inputStream a stream containing at least one [VertexProperty] as written by the accompanying
     * [GraphWriter.writeVertexProperty] method.
     * @param vertexPropertyAttachMethod a function that creates re-attaches a [VertexProperty] to a
     * [Host] object.
     */
    @Override
    @Throws(IOException::class)
    fun readVertexProperty(
        inputStream: InputStream?,
        vertexPropertyAttachMethod: Function<Attachable<VertexProperty?>?, VertexProperty?>
    ): VertexProperty {
        return if (version === GraphSONVersion.V1_0) {
            val vpData: Map<String, Object> = mapper.readValue(inputStream, mapTypeReference)
            val vp = DetachedVertexProperty(
                vpData[GraphSONTokens.ID],
                vpData[GraphSONTokens.LABEL].toString(),
                vpData[GraphSONTokens.VALUE], vpData[GraphSONTokens.PROPERTIES]
            )
            vertexPropertyAttachMethod.apply(vp)
        } else {
            vertexPropertyAttachMethod.apply(
                mapper.readValue(
                    inputStream,
                    VertexProperty::class.java
                ) as DetachedVertexProperty
            )
        }
    }

    /**
     * Read a [Property] from output generated by  [GraphSONWriter.writeProperty] or
     * via an [Property] passed to [GraphSONWriter.writeObject].
     *
     * @param inputStream a stream containing at least one [Property] as written by the accompanying
     * [GraphWriter.writeProperty] method.
     * @param propertyAttachMethod a function that creates re-attaches a [Property] to a [Host] object.
     */
    @Override
    @Throws(IOException::class)
    fun readProperty(
        inputStream: InputStream?,
        propertyAttachMethod: Function<Attachable<Property?>?, Property?>
    ): Property {
        return if (version === GraphSONVersion.V1_0) {
            val propertyData: Map<String, Object> = mapper.readValue(inputStream, mapTypeReference)
            val p = DetachedProperty(propertyData[GraphSONTokens.KEY].toString(), propertyData[GraphSONTokens.VALUE])
            propertyAttachMethod.apply(p)
        } else {
            propertyAttachMethod.apply(mapper.readValue(inputStream, Property::class.java) as DetachedProperty)
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Throws(IOException::class)
    fun <C> readObject(inputStream: InputStream?, clazz: Class<out C>?): C {
        return mapper.readValue(inputStream, clazz)
    }

    @Throws(IOException::class)
    private fun readVertexStrings(inputStream: InputStream): Stream<String> {
        return if (unwrapAdjacencyList) {
            val root: JsonNode = mapper.readTree(inputStream)
            val vertices: JsonNode = root.get(GraphSONTokens.VERTICES)
            if (!vertices.getNodeType()
                    .equals(JsonNodeType.ARRAY)
            ) throw IOException(String.format("The '%s' key must be an array", GraphSONTokens.VERTICES))
            IteratorUtils.stream(vertices.elements()).map(Object::toString)
        } else {
            val br = BufferedReader(InputStreamReader(inputStream))
            br.lines()
        }
    }

    class Builder private constructor() : ReaderBuilder<GraphSONReader?> {
        private var batchSize: Long = 10000
        private var mapper: Mapper<ObjectMapper> = GraphSONMapper.build().create()
        private var unwrapAdjacencyList = false

        /**
         * Number of mutations to perform before a commit is executed when using
         * [GraphSONReader.readGraph].
         */
        fun batchSize(batchSize: Long): Builder {
            this.batchSize = batchSize
            return this
        }

        /**
         * Override all of the [GraphSONMapper] builder
         * options with this mapper.  If this value is set to something other than null then that value will be
         * used to construct the writer.
         */
        fun mapper(mapper: Mapper<ObjectMapper?>): Builder {
            this.mapper = mapper
            return this
        }

        /**
         * If the adjacency list is wrapped in a JSON object, as is done when writing a graph with
         * [GraphSONWriter.Builder.wrapAdjacencyList] wrapAdjacencyList} set to `true`, this
         * setting needs to be set to `true` to properly read it.  By default, this value is `false` and
         * the adjacency list is simply read as line delimited vertices.
         *
         *
         * By setting this value to `true`, the generated JSON is no longer "splittable" by line and thus not
         * suitable for OLAP processing.  Furthermore, reading this format of the JSON with
         * [GraphSONReader.readGraph] or
         * [GraphSONReader.readVertices] requires that the
         * entire JSON object be read into memory, so it is best saved for "small" graphs.
         */
        fun unwrapAdjacencyList(unwrapAdjacencyList: Boolean): Builder {
            this.unwrapAdjacencyList = unwrapAdjacencyList
            return this
        }

        fun create(): GraphSONReader {
            return GraphSONReader(this)
        }
    }

    companion object {
        fun build(): Builder {
            return Builder()
        }
    }
}