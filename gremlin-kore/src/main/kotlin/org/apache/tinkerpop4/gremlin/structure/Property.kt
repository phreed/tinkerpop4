/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.tinkerpop4.gremlin.structure

import org.apache.tinkerpop4.gremlin.structure.util.empty.EmptyProperty

/**
 * A [Property] denotes a key/value pair associated with an [Edge]. A property is much like a Java8
 * `Optional` in that a property can be not present (i.e. empty). The key of a property is always a
 * String and the value of a property is an arbitrary Java object. Each underlying graph engine will typically have
 * constraints on what Java objects are allowed to be used as values.
 *
 * @author Marko A. Rodriguez (http://markorodriguez.com)
 * @author Stephen Mallette (http://stephen.genoprime.com)
 */
interface Property<V> {
    /**
     * The key of the property.
     *
     * @return The property key
     */
    fun key(): String?

    /**
     * The value of the property.
     *
     * @return The property value
     * @throws NoSuchElementException thrown if the property is empty
     */
    @Throws(NoSuchElementException::class)
    fun value(): V

    /**
     * Whether the property is empty or not.
     *
     * @return True if the property exists, else false
     */
    val isPresent: Boolean

    /**
     * If the property is present, the consume the value as specified by the [Consumer].
     *
     * @param consumer The consumer to process the existing value.
     */
    fun ifPresent(consumer: Consumer<in V>) {
        if (isPresent) consumer.accept(value())
    }

    /**
     * If the value is present, return the value, else return the provided value.
     *
     * @param otherValue The value to return if the property is not present
     * @return A value
     */
    fun orElse(otherValue: V): V {
        return if (isPresent) value() else otherValue
    }

    /**
     * If the value is present, return the value, else generate a value given the [Supplier].
     *
     * @param valueSupplier The supplier to use to generate a value if the property is not present
     * @return A value
     */
    fun orElseGet(valueSupplier: Supplier<out V>): V {
        return if (isPresent) value() else valueSupplier.get()
    }

    /**
     * If the value is present, return the value, else throw the exception generated by the [Supplier].
     *
     * @param exceptionSupplier The supplier to generate an exception if the property is not present
     * @param <E>               The exception type
     * @return A value
     * @throws E if the property is not present, the exception is thrown
    </E> */
    @Throws(E::class)
    fun <E : Throwable?> orElseThrow(exceptionSupplier: Supplier<out E>): V {
        return if (isPresent) value() else throw exceptionSupplier.get()
    }

    /**
     * Get the element that this property is associated with.
     *
     * @return The element associated with this property (i.e. [Vertex], [Edge], or [VertexProperty]).
     */
    fun element(): Element?

    /**
     * Remove the property from the associated element.
     */
    fun remove()

    /**
     * Common exceptions to use with a property.
     */
    object Exceptions {
        fun propertyKeyCanNotBeEmpty(): IllegalArgumentException {
            return IllegalArgumentException("Property key can not be the empty string")
        }

        fun propertyKeyCanNotBeNull(): IllegalArgumentException {
            return IllegalArgumentException("Property key can not be null")
        }

        fun propertyKeyCanNotBeAHiddenKey(key: String): IllegalArgumentException {
            return IllegalArgumentException("Property key can not be a hidden key: $key")
        }

        fun propertyDoesNotExist(): IllegalStateException {
            return IllegalStateException("The property does not exist as it has no key, value, or associated element")
        }

        fun propertyDoesNotExist(element: Element, key: String): IllegalStateException {
            return IllegalStateException("The property does not exist as the key has no associated value for the provided element: $element:$key")
        }

        fun dataTypeOfPropertyValueNotSupported(`val`: Object): IllegalArgumentException {
            return dataTypeOfPropertyValueNotSupported(`val`, null)
        }

        fun dataTypeOfPropertyValueNotSupported(`val`: Object, rootCause: Exception?): IllegalArgumentException {
            return IllegalArgumentException(
                String.format(
                    "Property value [%s] is of type %s is not supported",
                    `val`,
                    `val`.getClass()
                ), rootCause
            )
        }

        fun propertyRemovalNotSupported(): IllegalStateException {
            return IllegalStateException("Property removal is not supported")
        }
    }

    companion object {
        /**
         * Create an empty property that is not present.
         *
         * @param <V> The value class of the empty property
         * @return A property that is not present
        </V> */
        fun <V> empty(): Property<V>? {
            return EmptyProperty.instance()
        }
    }
}